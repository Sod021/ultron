import { useState } from 'react';
import { format, parseISO } from 'date-fns';
import { Calendar as CalendarIcon, Download, Save, Loader2 } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Textarea } from '@/components/ui/textarea';
import { Badge } from '@/components/ui/badge';
import { Calendar } from '@/components/ui/calendar';
import { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { useToast } from '@/hooks/use-toast';
import { useDailyChecks } from '@/hooks/useDailyChecks';
import { useReportFixes } from '@/hooks/useReportFixes';
import { jsPDF } from 'jspdf';
import autoTable, { CellDef } from 'jspdf-autotable';

interface ReportPatcherProps {
  currentUser: string;
}

export const ReportPatcher = ({ currentUser }: ReportPatcherProps) => {
  const { toast } = useToast();
  const { getChecksByDate } = useDailyChecks();
  const { getFixesByCheckId, saveFix, isLoading: isSaving } = useReportFixes();
  
  const [selectedDate, setSelectedDate] = useState<Date>();
  const [reportData, setReportData] = useState<any[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [fixes, setFixes] = useState<Record<number, any>>({});


  const loadReport = async () => {
    if (!selectedDate) {
      toast({
        title: 'Error',
        description: 'Please select a date',
        variant: 'destructive',
      });
      return;
    }

    setIsLoading(true);
    try {
      const dateStr = selectedDate.toISOString().split('T')[0];
      const checks = await getChecksByDate(dateStr);
      
      // Fetch existing fixes for these checks
      const fixesData: Record<number, any> = {};
      await Promise.all(
        checks.map(async (check: any) => {
          const fix = await getFixesByCheckId(check.id);
          if (fix) {
            fixesData[check.id] = fix;
          } else {
            // Initialize with default values
            fixesData[check.id] = {
              daily_check_id: check.id,
              fix_notes: '',
              fixed_by: currentUser,
              status: 'pending',
            };
          }
        })
      );

      setReportData(checks);
      setFixes(fixesData);
    } catch (error) {
      console.error('Error loading report:', error);
      toast({
        title: 'Error',
        description: 'Failed to load report',
        variant: 'destructive',
      });
    } finally {
      setIsLoading(false);
    }
  };

  const handleFixChange = (checkId: number, field: string, value: any) => {
    setFixes(prev => ({
      ...prev,
      [checkId]: {
        ...prev[checkId],
        [field]: value,
      },
    }));
  };

  const saveAllFixes = async () => {
    try {
      for (const checkId in fixes) {
        const fix = fixes[checkId];
        if (fix.fix_notes.trim()) {
          await saveFix({
            ...fix,
            fixed_by: currentUser,
          });
        }
      }
      
      toast({
        title: 'Success',
        description: 'All fixes saved successfully',
      });
    } catch (error) {
      console.error('Error saving fixes:', error);
      toast({
        title: 'Error',
        description: 'Failed to save some fixes',
        variant: 'destructive',
      });
    }
  };

  const formatFixedAt = (value?: string) => {
    if (!value) return '-';
    const isoDate = parseISO(value);
    if (!Number.isNaN(isoDate.getTime())) return format(isoDate, 'PPpp');
    const fallbackDate = new Date(value);
    if (!Number.isNaN(fallbackDate.getTime())) return format(fallbackDate, 'PPpp');
    return value;
  };

  const exportToPDF = () => {
    if (reportData.length === 0) return;

    const doc = new jsPDF({
      orientation: 'l',
      unit: 'mm',
      format: 'a4'
    });
    const dateStr = selectedDate ? format(selectedDate, 'yyyy-MM-dd') : 'report';
    
    // Add title
    doc.setFont('courier', 'bold');
    doc.setFontSize(22);
    doc.text(`Patched Report - ${dateStr}`, 14, 20);
    doc.setFont('courier', 'normal');
    doc.setFontSize(12);
    doc.setTextColor(100);
    doc.text(`Generated on: ${new Date().toLocaleString()}`, 14, 30);
    doc.text(`Generated by: ${currentUser}`, 14, 38);

    // Prepare data for the table
    const tableData: CellDef[][] = reportData.map((check) => [
      {
        content: `${check.website_name}\n${check.website_url}`,
        styles: { halign: 'left', fontStyle: 'normal' as const }
      },
      {
        content: check.is_live ? 'Yes' : 'No',
        styles: {
          halign: 'center',
          textColor: check.is_live ? [0, 150, 0] as [number, number, number] : [200, 0, 0] as [number, number, number]
        }
      },
      {
        content: check.is_functional ? 'Yes' : 'No',
        styles: {
          halign: 'center',
          textColor: check.is_functional ? [0, 150, 0] as [number, number, number] : [200, 0, 0] as [number, number, number]
        }
      },
      {
        content: check.has_problem ? 'Yes' : 'No',
        styles: {
          halign: 'center',
          textColor: check.has_problem ? [200, 0, 0] as [number, number, number] : [100, 100, 100] as [number, number, number]
        }
      },
      {
        content: check.notes || '-',
        styles: { halign: 'left', fontStyle: 'normal' as const }
      },
      {
        content: fixes[check.id]?.status || 'Not fixed',
        styles: {
          halign: 'center',
          textColor:
            fixes[check.id]?.status === 'fixed'
              ? ([0, 150, 0] as [number, number, number])
              : fixes[check.id]?.status === 'wont_fix'
                ? ([200, 0, 0] as [number, number, number])
                : ([100, 100, 100] as [number, number, number])
        }
      },
      {
        content: fixes[check.id]?.fix_notes || '-',
        styles: { halign: 'left', fontStyle: 'normal' as const }
      },
      {
        content: fixes[check.id]?.fixed_by || '-',
        styles: { halign: 'left', fontStyle: 'normal' as const }
      },
      {
        content: formatFixedAt(fixes[check.id]?.fixed_at),
        styles: { halign: 'left', fontStyle: 'normal' as const }
      },
    ]);

    const margin = 10;
    const totalWidth = 297 - (2 * margin);
    const colWidths = [
      totalWidth * 0.18, // Website
      totalWidth * 0.08, // Live
      totalWidth * 0.08, // Functional
      totalWidth * 0.08, // Issue
      totalWidth * 0.14, // Original Notes
      totalWidth * 0.08, // Status
      totalWidth * 0.14, // Fix Notes
      totalWidth * 0.1,  // Fixed By
      totalWidth * 0.12  // Fixed At
    ];

    // Add table
    autoTable(doc, {
      head: [
        ['Website', 'Live', 'Functional', 'Issue', 'Original Notes', 'Status', 'Fix Notes', 'Fixed By', 'Fixed At']
      ],
      body: tableData,
      startY: 48,
      theme: 'grid',
      margin: { left: margin, right: margin },
      styles: {
        font: 'courier',
        fontSize: 10,
        cellPadding: 3,
        lineColor: [200, 200, 200],
        lineWidth: 0.1,
        overflow: 'linebreak',
        textColor: [0, 0, 0]
      },
      headStyles: {
        fillColor: [241, 243, 245],
        textColor: [0, 0, 0],
        font: 'courier',
        fontSize: 9,
        halign: 'center',
        lineWidth: 0.1,
        cellPadding: 6
      },
      columnStyles: {
        0: { cellWidth: colWidths[0], halign: 'left', valign: 'middle' },
        1: { cellWidth: colWidths[1], halign: 'center', valign: 'middle' },
        2: { cellWidth: colWidths[2], halign: 'center', valign: 'middle' },
        3: { cellWidth: colWidths[3], halign: 'center', valign: 'middle' },
        4: { cellWidth: colWidths[4], halign: 'left', valign: 'middle' },
        5: { cellWidth: colWidths[5], halign: 'center', valign: 'middle' },
        6: { cellWidth: colWidths[6], halign: 'left', valign: 'middle' },
        7: { cellWidth: colWidths[7], halign: 'left', valign: 'middle' },
        8: { cellWidth: colWidths[8], halign: 'left', valign: 'middle' },
      },
    });

    // Save the PDF
    doc.save(`patched-report-${dateStr}.pdf`);
  };

  const getStatusBadge = (status: string) => {
    switch (status) {
      case 'fixed':
        return <Badge className="bg-green-500 hover:bg-green-600">Fixed</Badge>;
      case 'wont_fix':
        return <Badge variant="destructive">Won't Fix</Badge>;
      default:
        return <Badge variant="outline">Pending</Badge>;
    }
  };

  return (
    <div className="space-y-6">
      <Card>
        <CardHeader>
          <CardTitle>Load Report</CardTitle>
          <CardDescription>Select a date to load the report for patching</CardDescription>
        </CardHeader>
        <CardContent>
          <div className="flex flex-col sm:flex-row gap-4">
            <div className="flex-1">
              <Popover>
                <PopoverTrigger asChild>
                  <Button
                    variant="outline"
                    className="w-full justify-start text-left font-normal"
                  >
                    <CalendarIcon className="mr-2 h-4 w-4" />
                    {selectedDate ? format(selectedDate, 'PPP') : <span>Pick a date</span>}
                  </Button>
                </PopoverTrigger>
                <PopoverContent className="w-auto p-0" align="start">
                  <Calendar
                    mode="single"
                    selected={selectedDate}
                    onSelect={setSelectedDate}
                    initialFocus
                  />
                </PopoverContent>
              </Popover>
            </div>
            <Button onClick={loadReport} disabled={!selectedDate || isLoading}>
              {isLoading ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : null}
              Load Report
            </Button>
          </div>
        </CardContent>
      </Card>

      {reportData.length > 0 && (
        <Card>
          <CardHeader className="flex flex-row items-center justify-between">
            <div>
              <CardTitle>Report for {format(selectedDate!, 'PPP')}</CardTitle>
              <CardDescription>
                {reportData.length} website{reportData.length !== 1 ? 's' : ''} found
              </CardDescription>
            </div>
            <div className="flex gap-2">
              <Button variant="outline" onClick={exportToPDF}>
                <Download className="mr-2 h-4 w-4" />
                Export PDF
              </Button>
              <Button onClick={saveAllFixes} disabled={isSaving}>
                {isSaving ? (
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                ) : (
                  <Save className="mr-2 h-4 w-4" />
                )}
                Save All Fixes
              </Button>
            </div>
          </CardHeader>
          <CardContent>
            <div className="space-y-6">
              {reportData.map((check) => (
                <div key={check.id} className="border rounded-lg p-4 space-y-4">
                  <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-2">
                    <div>
                      <h3 className="font-medium">{check.website_name}</h3>
                      <a
                        href={check.website_url}
                        target="_blank"
                        rel="noopener noreferrer"
                        className="text-sm text-blue-600 hover:underline flex items-center gap-1"
                      >
                        {check.website_url}
                      </a>
                    </div>
                    <div className="flex flex-wrap gap-2">
                      <Badge variant={check.is_live ? 'default' : 'destructive'}>
                        {check.is_live ? 'Live' : 'Not Live'}
                      </Badge>
                      <Badge variant={check.is_functional ? 'default' : 'destructive'}>
                        {check.is_functional ? 'Functional' : 'Not Functional'}
                      </Badge>
                      <Badge variant={check.has_problem ? 'destructive' : 'default'}>
                        {check.has_problem ? 'Has Issues' : 'No Issues'}
                      </Badge>
                    </div>
                  </div>
                  
                  <div>
                    <Label>Original Notes</Label>
                    <p className="text-sm text-muted-foreground">{check.notes || 'No notes'}</p>
                  </div>
                  
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                      <Label htmlFor={`status-${check.id}`}>Status</Label>
                      <Select
                        value={fixes[check.id]?.status || 'pending'}
                        onValueChange={(value) => handleFixChange(check.id, 'status', value)}
                      >
                        <SelectTrigger>
                          <SelectValue placeholder="Select status" />
                        </SelectTrigger>
                        <SelectContent>
                          <SelectItem value="pending">Pending</SelectItem>
                          <SelectItem value="fixed">Fixed</SelectItem>
                          <SelectItem value="wont_fix">Won't Fix</SelectItem>
                        </SelectContent>
                      </Select>
                    </div>
                    <div>
                      <Label>Fixed By</Label>
                      <Select
                        value={
                          fixes[check.id]?.fixed_by === 'Hostinger AI Troubleshooter' ||
                          fixes[check.id]?.fixed_by === currentUser
                            ? fixes[check.id]?.fixed_by
                            : '__manual__'
                        }
                        onValueChange={(value) => {
                          if (value === '__manual__') {
                            handleFixChange(check.id, 'fixed_by', '');
                          } else {
                            handleFixChange(check.id, 'fixed_by', value);
                          }
                        }}
                      >
                        <SelectTrigger>
                          <SelectValue placeholder="Select who fixed this" />
                        </SelectTrigger>
                        <SelectContent>
                          <SelectItem value="Hostinger AI Troubleshooter">Hostinger AI Troubleshooter</SelectItem>
                          <SelectItem value={currentUser}>Me</SelectItem>
                          <SelectItem value="__manual__">Manual</SelectItem>
                        </SelectContent>
                      </Select>
                      {(fixes[check.id]?.fixed_by ?? '') === '' && (
                        <Input
                          className="mt-2"
                          value={fixes[check.id]?.fixed_by || ''}
                          onChange={(e) => handleFixChange(check.id, 'fixed_by', e.target.value)}
                          placeholder="Type a name..."
                        />
                      )}
                    </div>
                  </div>
                  
                  <div>
                    <Label htmlFor={`fix-notes-${check.id}`}>Fix Notes</Label>
                    <Textarea
                      id={`fix-notes-${check.id}`}
                      value={fixes[check.id]?.fix_notes || ''}
                      onChange={(e) => handleFixChange(check.id, 'fix_notes', e.target.value)}
                      placeholder="Describe what was fixed or why it won't be fixed..."
                      rows={3}
                    />
                  </div>
                  
                  {formatFixedAt(fixes[check.id]?.fixed_at) !== '-' && (
                    <div className="text-xs text-muted-foreground">
                      Last updated: {formatFixedAt(fixes[check.id]?.fixed_at)}
                    </div>
                  )}
                </div>
              ))}
            </div>
          </CardContent>
        </Card>
      )}
    </div>
  );
};
