-- =========================================================
-- Issue Tracker Collaboration (rerunnable)
-- - Project-level collaboration via memberships and invites
-- - Role + optional permission override model
-- - Updated RLS for issue_projects and issue_tracker_issues
-- =========================================================

-- Needed for citext invite emails and uuid token defaults
create extension if not exists citext;
create extension if not exists "uuid-ossp";

-- ---------------------------------------------------------
-- Memberships
-- ---------------------------------------------------------
create table if not exists public.project_members (
  project_id bigint not null references public.issue_projects(id) on delete cascade,
  user_id uuid not null references auth.users(id) on delete cascade,
  role text not null check (role in ('admin', 'editor', 'viewer')),
  permissions jsonb not null default '{}'::jsonb,
  created_at timestamptz not null default now(),
  invited_by uuid references auth.users(id) on delete set null,
  primary key (project_id, user_id)
);

create index if not exists project_members_user_id_idx on public.project_members (user_id);
create index if not exists project_members_project_id_idx on public.project_members (project_id);

-- ---------------------------------------------------------
-- Invites
-- ---------------------------------------------------------
create table if not exists public.project_invites (
  id bigint generated by default as identity primary key,
  project_id bigint not null references public.issue_projects(id) on delete cascade,
  invited_email citext not null,
  role text not null check (role in ('admin', 'editor', 'viewer')),
  permissions jsonb not null default '{}'::jsonb,
  invited_by uuid not null references auth.users(id) on delete cascade,
  token uuid not null default uuid_generate_v4(),
  status text not null default 'pending' check (status in ('pending', 'accepted', 'revoked', 'expired')),
  expires_at timestamptz not null default (now() + interval '7 days'),
  created_at timestamptz not null default now()
);

create index if not exists project_invites_project_id_idx on public.project_invites (project_id);
create index if not exists project_invites_invited_email_idx on public.project_invites (invited_email);
create index if not exists project_invites_status_idx on public.project_invites (status);
create unique index if not exists project_invites_pending_unique
  on public.project_invites (project_id, invited_email)
  where status = 'pending';

-- ---------------------------------------------------------
-- Role cleanup + rerunnable constraints
-- ---------------------------------------------------------
update public.project_members
set role = 'editor'
where role = 'reporter';

update public.project_invites
set role = 'editor'
where role = 'reporter';

alter table public.project_members drop constraint if exists project_members_role_check;
alter table public.project_members
  add constraint project_members_role_check
  check (role in ('admin', 'editor', 'viewer'));

alter table public.project_invites drop constraint if exists project_invites_role_check;
alter table public.project_invites
  add constraint project_invites_role_check
  check (role in ('admin', 'editor', 'viewer'));

-- ---------------------------------------------------------
-- Backfill: owner as admin member for existing projects
-- ---------------------------------------------------------
insert into public.project_members (project_id, user_id, role, permissions, invited_by)
select p.id, p.user_id, 'admin', '{}'::jsonb, p.user_id
from public.issue_projects p
on conflict (project_id, user_id) do nothing;

-- ---------------------------------------------------------
-- Permission helper
-- ---------------------------------------------------------
create or replace function public.has_project_permission(p_project_id bigint, p_permission text)
returns boolean
language plpgsql
security definer
set search_path = public
as $$
declare
  owner_id uuid;
  member_role text;
  member_permissions jsonb;
begin
  if auth.uid() is null then
    return false;
  end if;

  select ip.user_id into owner_id
  from public.issue_projects ip
  where ip.id = p_project_id;

  if owner_id is null then
    return false;
  end if;

  -- Project owner always has full access
  if owner_id = auth.uid() then
    return true;
  end if;

  select pm.role, pm.permissions
  into member_role, member_permissions
  from public.project_members pm
  where pm.project_id = p_project_id
    and pm.user_id = auth.uid();

  if member_role is null then
    return false;
  end if;

  -- Admin role has full access
  if member_role = 'admin' then
    return true;
  end if;

  -- Explicit permission override (if provided)
  if member_permissions ? p_permission then
    return coalesce((member_permissions ->> p_permission)::boolean, false);
  end if;

  -- Role defaults
  if p_permission = 'project.view' then
    return true;
  end if;

  if member_role = 'editor' then
    return p_permission in ('issue.create', 'issue.edit', 'issue.delete', 'issue.status.update', 'issue.comment');
  end if;

  return false;
end;
$$;

grant execute on function public.has_project_permission(bigint, text) to authenticated;

-- ---------------------------------------------------------
-- Project creation helper (owner flow)
-- ---------------------------------------------------------
create or replace function public.create_issue_project(p_name text)
returns public.issue_projects
language plpgsql
security definer
set search_path = public
as $$
declare
  v_project public.issue_projects;
begin
  if auth.uid() is null then
    raise exception 'Not authenticated';
  end if;

  if coalesce(trim(p_name), '') = '' then
    raise exception 'Project name required';
  end if;

  insert into public.issue_projects (user_id, name)
  values (auth.uid(), trim(p_name))
  returning * into v_project;

  return v_project;
end;
$$;

grant execute on function public.create_issue_project(text) to authenticated;

-- ---------------------------------------------------------
-- Invite acceptance helper (invited user flow)
-- ---------------------------------------------------------
create or replace function public.accept_project_invite(p_invite_id bigint)
returns void
language plpgsql
security definer
set search_path = public
as $$
declare
  v_invite public.project_invites%rowtype;
begin
  if auth.uid() is null then
    raise exception 'Not authenticated';
  end if;

  select *
  into v_invite
  from public.project_invites
  where id = p_invite_id
    and status = 'pending';

  if not found then
    raise exception 'Invite not found or no longer pending';
  end if;

  if lower(v_invite.invited_email::text) <> lower(coalesce(auth.jwt() ->> 'email', '')) then
    raise exception 'Invite email does not match signed-in user';
  end if;

  if v_invite.expires_at < now() then
    update public.project_invites
    set status = 'expired'
    where id = v_invite.id;
    raise exception 'Invite has expired';
  end if;

  insert into public.project_members (project_id, user_id, role, permissions, invited_by)
  values (v_invite.project_id, auth.uid(), v_invite.role, coalesce(v_invite.permissions, '{}'::jsonb), v_invite.invited_by)
  on conflict (project_id, user_id)
  do update set
    role = excluded.role,
    permissions = excluded.permissions,
    invited_by = excluded.invited_by;

  update public.project_invites
  set status = 'accepted'
  where id = v_invite.id;
end;
$$;

grant execute on function public.accept_project_invite(bigint) to authenticated;

-- ---------------------------------------------------------
-- RLS enable
-- ---------------------------------------------------------
alter table public.project_members enable row level security;
alter table public.project_invites enable row level security;
alter table public.issue_projects enable row level security;
alter table public.issue_tracker_issues enable row level security;

-- ---------------------------------------------------------
-- Policies: project_members
-- ---------------------------------------------------------
drop policy if exists "project_members_select" on public.project_members;
drop policy if exists "project_members_insert" on public.project_members;
drop policy if exists "project_members_update" on public.project_members;
drop policy if exists "project_members_delete" on public.project_members;

create policy "project_members_select" on public.project_members
for select using (
  user_id = auth.uid()
  or public.has_project_permission(project_id, 'member.view')
);

create policy "project_members_insert" on public.project_members
for insert with check (
  public.has_project_permission(project_id, 'member.invite')
);

create policy "project_members_update" on public.project_members
for update using (
  public.has_project_permission(project_id, 'member.role.update')
);

create policy "project_members_delete" on public.project_members
for delete using (
  public.has_project_permission(project_id, 'member.remove')
);

-- ---------------------------------------------------------
-- Policies: project_invites
-- ---------------------------------------------------------
drop policy if exists "project_invites_select" on public.project_invites;
drop policy if exists "project_invites_insert" on public.project_invites;
drop policy if exists "project_invites_update" on public.project_invites;
drop policy if exists "project_invites_delete" on public.project_invites;

create policy "project_invites_select" on public.project_invites
for select using (
  public.has_project_permission(project_id, 'member.invite')
  or lower(invited_email::text) = lower(coalesce(auth.jwt() ->> 'email', ''))
);

create policy "project_invites_insert" on public.project_invites
for insert with check (
  public.has_project_permission(project_id, 'member.invite')
);

create policy "project_invites_update" on public.project_invites
for update using (
  public.has_project_permission(project_id, 'member.invite')
);

create policy "project_invites_delete" on public.project_invites
for delete using (
  public.has_project_permission(project_id, 'member.invite')
);

-- ---------------------------------------------------------
-- Policies: issue_projects (replace own-only with collab)
-- ---------------------------------------------------------
drop policy if exists "issue_projects_select_own" on public.issue_projects;
drop policy if exists "issue_projects_insert_own" on public.issue_projects;
drop policy if exists "issue_projects_update_own" on public.issue_projects;
drop policy if exists "issue_projects_delete_own" on public.issue_projects;
drop policy if exists "issue_projects_select_access" on public.issue_projects;
drop policy if exists "issue_projects_insert_access" on public.issue_projects;
drop policy if exists "issue_projects_update_access" on public.issue_projects;
drop policy if exists "issue_projects_delete_access" on public.issue_projects;

create policy "issue_projects_select_access" on public.issue_projects
for select using (
  public.has_project_permission(id, 'project.view')
);

create policy "issue_projects_insert_access" on public.issue_projects
for insert with check (
  auth.uid() = user_id
);

create policy "issue_projects_update_access" on public.issue_projects
for update using (
  public.has_project_permission(id, 'project.edit')
);

create policy "issue_projects_delete_access" on public.issue_projects
for delete using (
  public.has_project_permission(id, 'project.delete')
);

-- ---------------------------------------------------------
-- Policies: issue_tracker_issues (replace own-only with collab)
-- ---------------------------------------------------------
drop policy if exists "issue_tracker_issues_select_own" on public.issue_tracker_issues;
drop policy if exists "issue_tracker_issues_insert_own" on public.issue_tracker_issues;
drop policy if exists "issue_tracker_issues_update_own" on public.issue_tracker_issues;
drop policy if exists "issue_tracker_issues_delete_own" on public.issue_tracker_issues;
drop policy if exists "issue_tracker_issues_select_access" on public.issue_tracker_issues;
drop policy if exists "issue_tracker_issues_insert_access" on public.issue_tracker_issues;
drop policy if exists "issue_tracker_issues_update_access" on public.issue_tracker_issues;
drop policy if exists "issue_tracker_issues_delete_access" on public.issue_tracker_issues;

create policy "issue_tracker_issues_select_access" on public.issue_tracker_issues
for select using (
  public.has_project_permission(project_id, 'project.view')
);

create policy "issue_tracker_issues_insert_access" on public.issue_tracker_issues
for insert with check (
  user_id = auth.uid()
  and public.has_project_permission(project_id, 'issue.create')
);

create policy "issue_tracker_issues_update_access" on public.issue_tracker_issues
for update using (
  public.has_project_permission(project_id, 'issue.edit')
);

create policy "issue_tracker_issues_delete_access" on public.issue_tracker_issues
for delete using (
  public.has_project_permission(project_id, 'issue.delete')
);
